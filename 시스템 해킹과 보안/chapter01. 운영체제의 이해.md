# 운영체제의 개념과 기능
## 1. 운영체제의 개념
운영체제는 컴퓨터 시스템을 손쉽게 사용하도록 하고, 시스템 자원을 효율적으로 관리할 수 있는 프로그램 집합이라고 윌리엄 스탈링스는 말했다.   
시스템 자원이란 기억장치, 프로세서, 입출력장치, 정보, 네트워크 등을 말한다.
## 2. 운영체제의 기능
운영체제는 굉장히 다양하지만 일반적인 pc에서는 단일 사용자 운영체제 구성 모델, 즉 UCI(사용자 명령 인터페이스)를 중심으로 네 가지 서브시스템 관리자로 구성된다.   
네트워크를 지원하는 운영체제는 네트워크 관리자가 추가된다.   
서브시스템 관리자는 메모리 관리자, 프로세서 관리자, 장치 관리자, 파일 관리자 등이 있다. 
### 2-1. 사용자 명령 인터페이스
사용자와 시스템의 대화수단이다.   
DOS나 유닉스에서는 쉘이, 최근의 운영체제에서는 GUI적용으로 아이콘, 메뉴, 마우스를 이용해 시스템과 소통한다.
### 2-2. 서브시스템 관리자
* ##### 메모리 관리자
프로그램이 메모리를 요청하면 적합성을 점검하고, 적합할 시 메모리를 할당해준다.   
또한 할당된 메모리를 관리, 보호하고, 프로그램 종료 시 할당된 메모리를 회수한다.
* ##### 프로세서 관리자
프로그램을 실행할 때 명령어(Instruction)를 체계적이고, 효율적으로 실행할 수 있도록 작업스케줄링을 한다.   
사용자의 작업 요청을 수용하거나 거부한다.
* ##### 장치 관리자
프린터, 디스크 드라이버, 모뎀, 모니터 등 시스템 안의 모든 장치를 프로그램에 할당하거나 회수한다.   
대개의 장치는 입출력 장치이다.
* ##### 파일 관리자
시스템 안의 데이터, 응용프로그램 등 모든 파일에 사용자별로 파일 접근권한을 부여한다.   
접근 권한에 따라 파일을 할당하고 해제한다.
* ##### 네트워크 관리자
네트워크에서 접근 가능한 GPU, 메모리, 프린터, 디스크 드라이버, 모뎀, 모니터 같은 자원을 관리한다. 

---
# 윈도우의 이해
## 1. 윈도우의 역사
1981년에 MS-DOS 1.0으로 시작한다. 또한 MS-DOS는 IBM 컴퓨터의 개인용 운영체제로 선택된다.   
1983년에 MS-DOS 2.0이 나오는데, 하드 디스크를 여러 개 장착할 수 있었다.   
1985년에 윈도우는 계속하여 발전해서 윈도우 1.0을 발표했다. 다중 처리 환경과 작업 절차가 단순해졌으나 큰 주목을 모으지는 못 했다.   
1987년 윈도우 2.0을 발표하자 DOS에서 설정한 기본 메모리인 640KB 이상의 프로그램이 생겨나기 시작했다.   
1987년에는 윈도우 386을 발표했는데, 3년 후에 발표하는 윈도우 3.0의 기초가 되었다.   
1992년에 발표한 윈도우 3.1은 대부분의 PC에 윈도우를 설치하는 분위기를 이끌었다.
1993년에는 DOS에서 시작한 PC용 운영체제인 윈도우를 서버용 운영체제의 개념인 NT버전으로 출시했다.   
1995년에는 윈도우 95를 발표했는데, TCP/IP, 전화접속네트워크, 긴 파일 이름 등 새로운 기능이 많아졌다.   
1998년에는 윈도우 98을 발표했으며, OSR2 버전은 꽤 높은 안정성을 보여주었다.   
이후에도 30여 년 동안 윈도우는 다양한 종류의 운영체제를 선보였다.   
또한 다른 수많은 경쟁사가 있었지만 현재까지 건재하고 있다.   
## 2. 윈도우의 구조
윈도우는 커널 구조와 파일 시스템 구조이다.   
커널은 운영체제의 중심에 위치하며, 운영체제에서의 모든 작업을 제어한다.   
즉 커널은 인터럽트 처리, 프로세스 관리, 메모리 관리, 파일 시스템 관리, 프로그래밍 인터페이스 제공 등 운영체제의 기본 기능의 핵심이다.
> ##### 인터럽트란?   
>
> 컴퓨터에 갑자기 문제가 발생한 경우 CPU가 하드웨어적으로 상태를 체크하여 변화에 대응하는 것이다.   
> 인터럽트가 발생하면, 인터럽트 처리 루틴이 작동하여 인터럽트를 해결하고, 인터럽트가 생기기 이전의 상태로 복귀한다.   
>
> ##### 인터럽트의 종류   
> * 기계 검사 인터럽트
> 프로그램 실행 중 갑작스런 정전이나 기계적인 문제가 발생할 때
> * 외부 인터럽트
> 오퍼레이터나 타이머가 프로그램을 의도적으로 중단할 때
> * 입출력 인터럽트
> 입출력 종료나 입출력 오류로 CPU기능이 요청될 때
> * 프로그램 검사 인터럽트
> 프로그램 실행 중 보호된 기억 공간에 접근했거나, 불법적인 명령 수행 같은 프로그램 문제가 발생할 때
### 2-1. 윈도우의 커널 구조
리눅스와 기본 개념은 같으나 형태는 다르다.   
동작할 때 커널을 손상하면 안 되므로 접근 가능한 메모리에 로드하지 않는 것이 일반적이다.   
커널이 손상되면 부팅 할 때 오류 문자와 함께 블루 스크린을 표시하는데, 이때는 운영체제를 새로 설치해야 한다.   
윈도우 시스템은 보통 링구조로 되어있다.   
링구조란 밑에서부터 하드웨어 > HAL > 마이크로 커널 > 각종 관리자 > 응용프로그램 순으로 위치한다.   
각 보안요소를 충족하고, 개별적으로 운영할 때 시스템 보안 수준이 높은 상태로 유지될 것이라는 생각에 고안되었다.   
또한 각종 관리자까지의 각 단계를 커널 모드로 구분하고, 마지막 링은 사용자 모드로 구분한다.   
커널 모드는 기본적으로 사용자가 접근 할 수 없는 영역으로, 기본 관리 시스템이 위치한다.   
하지만 마이크로 커널이 HAL을 무시하고, 하드웨어와 통신 할 수 있는 것과 같이 보안에서 허점을 만들었다.   
HAL은 하드웨어와 개발된 소프트웨어가 원활히 통신할 수 있는 번역자 역할을 한다.    
마이크로 커널은 본래 커널의 역할을 여러 관리자에게 분담시키고, 자신은 하드웨어와 하는 통신만 제어함으로써 최소한의 커널이 되었다.   
윈도우 관리자는의 역할은 각 명칭만으로 어떤 역할을 하는지 대략 알 수 있다.
* 입출력 관리자
시스템의 입출력을 제어한다. 장치 드라이버에서의 메시지, 응용 프로그램이 하드웨어를 곧바로 통신할 수 있는 통로를 제공한다.
* 개체 관리자
파일, 포트, 프로세스, 스레드 등 모든 것을 개체로 정의하는데, 이런 각 개체의 정보를 제공한다.   
* 보안 참조 관리자
각 데이터나 시스템 자원의 제어를 허가하거나 거부함으로써 시스템의 강제 보안 설정을 제공한다.
* 프로세스 관리자
스레드를 생성하고 요청에 따라 처리한다.
* 로컬 프로시저 호출 관리자
프로세스는 서로의 메모리 공간을 침범하지 못해서, 프로세스 간 통신이 필요할때 이를 대신한다.
* 가상 메모리 관리자
응용 프로그램의 요청에 따라 RAM 메모리를 할당하고, 가상 메모리의 페이징을 제어한다. 
* 그래픽 장치 관리자
화면에 선이나 곡선을 그리거나 폰트 등을 관리한다.
* 기타 관리자
캐시 관리자, PNP 관리자, 전원 관리자 등이 있다.

사용자 모드에는 다양한 응용 프로그램과 응용프로그램을 실행하는 서브시스템이 있다.   
서브 시스템은 윈도우에서 여러 응용 프로그램을 실행하는 컨테이너라고 할 수 있다.   
서브 시스템 중 하나인 Win32는 32비트 응용 프로그램이 동작할 수 있도록 도와주고, 기본 윈도우 사용자 인터페이스를 제공한다.   
즉 비디오 디스플레이, 키보드, 마우스 등을 지원한다.   
윈도우7이나 2008부터는 64비트 서브시스템을 지공한다.   
이외에 보안 서브시스템과 유닉스 운영체제에 기반을 둔 일련의 표준 운영체제 인터페이스로 POSIX가 있다.   
이런 보안 서브시스템은 사용자가 로그인 할 때 데이터를 보호하고, 운영체제가 이를 제어할 수 있도록 한다.   
윈도우10부터는 윈도우 리눅스 서브시스템을 도입해 리눅스 운영체제를 설치해서 리눅스 프로그램도 실행할 수 있도록 하였다.   
### 2-2 윈도우의 파일 시스템
단순히 데이터를 저장하는 것이 목적이 아니라 다양한 설정 및 보안 사항과 관련이 있다.   
윈도우에는 FAT, FAT32, NTFS와 같은 파일 시스템이 있다.   
* FAT
윈도우 95부터 시작되었다.
기본적으로 2GB까지를 한 파티션으로 설정할 수 있다.
테이블의 기본 크기는 16비트인데, 이는 하드 디스크에 파일을 담는 최소 단위인 클러스터가 32KB이기 때문이다.   
초기에는 충분한 듯 보였으나, 얼마 지나지 않아 너무 작게 여겨졌다.
* FAT32
윈도우 95 OSR2에서 시작되었다.
클러스터를 32비트개 가질 수 있어 기존의 FAT보다 비교할 수 없을 만큼 용량이 컸다.
현재에도 종종 사용되며, 호환성이 좋아 다른 운영체제에 정보를 옮길 때 유용하다.
그러나 접근 제어를 설정할 수 없다는 문제점으로 보안과는 거리가 먼 파일 시스템이다.
* NTFS
접근 제어가 적용된 윈도우 파일 시스템은 NT계열에서 사용되기 시작했다.
FAT와 OS/2파일 시스템이던 HPFS의 장점을 모아 만든 것이다.
개별 폴더와 파일에 사용 권한을 설정할 수 있고, 각 파일과 폴더에 해당 계정만 접근하여 읽을 수 있게 암호화 할 수 있기 때문에 보안이 다른 파일 시스템보다 좋다.
어떤 계정의 사람이 언제 파일을 열었는지, 파일을 성공적으로 열었는지를 알 수 있는 감사기능을 제공한다.
현재 윈도우에 적용된다.
## 윈도우의 부팅 순서
윈도우의 각 버전에 따라 부팅 프로세스가 다르다.
### 3-1. 윈도우 XP, 윈도우 서버 2000/2003의 부팅 순서
##### Step1. POST 실행
하드웨어 스스로가 시스템에 문제가 없는지 기본 사항을 검사하는 과정이다.   
BIOS가 POST를 실행하고, 라우터나 스위치 등 장비에서도 처음 스위치를 켤때 POST를 실행한다.   
그리고 하드웨어에서 문제를 발견하면 이 사실을 여러 방법으로 알린다.
##### Step2. 기본 부팅 관련 설정 상항 로드
CMOS에서 기본 부팅 매체 등 부팅 관련 사항을 설정한다.   
BIOS는 CMOS에 설정된 시스템 설정 사항 및 부팅과 관련된 여러 가지 정보를 읽어 시스템이 적용한다.
##### Step3. MBR(마스터 부트 레코드)로드
저장 매체의 첫 번째 섹터에 위치하는 512바이트 영역으로, 부팅 매체의 기본 파일 시스템 정보가 들어 있다.   
운영체제를 부팅할 때 저장 매체의 첫 번째 섹터를 호출하면 해당 부트 코드를 수행한다.   
부트 코드의 주 역할은 파티션 테이블에서 부팅 가능한 파티션을 찾아 해당 파티션의 부트 섹터를 호출하는 것이다.
부팅 가능한 파티션이 없으면 미리 정의된 오류 메시지를 출력한다. 
##### Step4. NTLDR 실행
하드 디스크의 부팅 파티션에 있는 프로그램으로 윈도우를 부팅할 수 있도록 간단한 파일 시스템을 실행한다.   
또한 boot.ini 파일 내용을 읽어 가능한 부팅 옵션을 보여준다.
boot.ini파일의 예시)
```
[boot loader]
timeout=30
default=multi(0)disk(0)rdisk(0)partiotion(3)\WINNT

[operating systems]
multi(0)disk(0)rdisk(0)partiotion(3)\WINNT="Windows 2000 Pro"
multi(0)disk(0)rdisk(0)partiotion(2)\WINNT="Windows NT Server Version 4.00"
```
timeout은 운영체제를 선택하는 화면에서 걸리는 대기 시간이다.   
default는 timeout동안 입력하지 않으면 default로 부팅한다.   
multi(0)은 SATA또는 E-IDE 컨트롤러를 가지는 디스크임을 나타낸다. 숫자 0은 첫 번째 컨트롤러를 의미한다.   
SCSI 컨트롤러에 부착된 디스크에서 부팅할 때는 multi(0) 대신 scsi(0)을 쓴다.   
disk(0)은 scsi로 시작할 때를 표현한다.   
rdisk(0)은 IDE, E-IDE, SCSI with BIOS방식의 디스크에 해당하는 표현이다. 여기에서도 0은 해당 컨트롤러의 첫 번째 디스크를 의미한다.   
partition(3)은 파티션 순서를 나타낸다. 1부터 시작하므로 세 번째 파티션에 운영체제가 있음을 나타낸다.   
[operating systems]에서는 선택할 수 있는 운영체제를 위의 규칙에 따라 나열한다.
##### Step5. NTDETECT.com 실행
NTDETECT는 NTLDR에서 제어권을 위임받아 시스템에 설치한 다음 하드웨어를 검사한다.
* PC의 CPU유형
* 버스 유형
* 비디오 보드 유형
* 키보드와 마우스 종류
* 컴퓨터에 장착된 직렬 포트와 병렬 포트
* 플로피 드라이브

NTDETECT가 문제없이 작동되면 레지스트리의 하드웨어키를 만든다.   
이 키는 HKEY_LOCAL_MACHINE에 있다.   
컴퓨터를 재부팅 할 때마다 만들기에 항상 현재의 하드웨어를 구성한다.
##### Step6. ntoskrnl.exe 실행
ntoskrnl은 HAL.DLL을 로드한다. ntoskrnl로드는 다음 네가지로 나누어 생각할 수 있다.
* 커널 로드
시스템 설정을 로드하고, 이것을 HKEY_LOCAL_MACHINE\System\Current\Controlset\Services에 저장한다.   
이 정보를 확인하여 로드할 드라이브와 그 순서를 결정한다.
* 커널 초기화
드라이버에서 현재 제어 설정을 검사하고 작업을 시작한다.
* 서비스 로드
세션 관리자 서브시스템(smss.exe)과 Win32 서브시스템을 로드한다.
* 서브시스템 시작
윈도우 서브시스템을 초기화한다. Win32서브시스템은 로그인을 처리하고 Winlogon.exe를 시작한다.   
Ctrl+Alt+Delete를 누르면 로그인 창을 활성화하고, 계정과 패스워드를 입력받아 로컬 보안 인증 서버(lsass.exe)에 보낸다.   
전달 받은 로컬 보안 인증 서버는 보안 계정 관리자에 저장된 정보와 비교하여 서로 일치하면 Userinit.exe프로세스가 HKEY_LOCAL_MACHINE\SOFTWARE\Microsft\Window NT\ CurrentVersion\Winlogon의 셸 값에서 참조되는 셸을 실행한다.
### 3-2 윈도우 비스타 이후 버전 부팅 순서
기존 부팅 순서와 약간 다르지만 기본 순서와 구성은 거의 같다.
##### Step1~3. POST 실행 및 기본 부팅 관련 설정 사항 로드, MBR 로드
POST와 CMOS에서 기본 부팅 관련 설정 사항 및 MBR 로딩은 위의 내용과 같다.
##### Step4. 윈도우 부트 서브시스템 실행
bootmgr.exe를 실행하고, 부트 설정 데이터(BCD)를 읽어 실행 가능한 운영체제의 목록을 보여준다.
이것은 NTLDR이 boot.ini를 읽어 보여주는 것과 같다.
BCD는 boot.ini처럼 텍스트 파일이 아니고, bcdedit.exe를 이용하여 편집이 가능하다.
##### Step5. 윈도우 OS 로더(winload.exe)실행
NTDETECT처럼 각종 장치 드라이버를 로드하고, ntoskrnl.exe를 실행한다.

---
# 리눅스/유닉스의 이해
## 1. 리눅스/유닉스의 역사
IBM의 AIX시스템은 대형 시스템에 많이 설치하며, 주로 공공기관과 정부 행정망에 사용한다.   
또 일부 대학이나 은행 등에서 대형 서버가 필요할 때도 사용한다.   
HP의 HP-UX는 대형서버도 있지만 주로 중소형 서버시장에서 많이 사용한다.   
국내 중소형 서버 시장에서는 유닉스 서버로 오라클의 솔라리스를 많이 사용한다.   
이외에도 DEC의 Digital UNIX, SGI의 IRIX, SCO의 SCO Unixware를 사용한다.   
리눅스 종류는 페도라, 레드햇, 우분투, FreeBSD, SuSE등이 있다.   
리눅스는 무료라서 웹 호스팅 업체 등에서 주로 쓰고, 대기업은 거의 쓰지 않는다.   
유닉스의 시초는 멀틱스라는 시분할 운영체제로 1963년부터 3년간 MIT, GE, 벨 연구소가 공동으로 개발하였다.   
GE가 하드웨어를 만들었고, PL/1이라는 언어로 개발했다.   
이후 1970년대에 PDP-7이 만들어졌다. PDP-7에는 파일 시스템 구성의 개념, 명령어 인터프리터의 개념, 각 명령이 새로운 프로세스를 형성해서 실행하도록 하는 개념이 모두 포함되어 있었다.   
1973년에는 C언어로 쓰여지 유닉스는 C언어 범용성으로 인해 여러 하드웨어에 이식 되었고, 마침내 기존 컴퓨터 업체에서도 관심을 갖었다.   
이후 유닉스는 많은 수정을 거쳤고, BSD라는 이름이 붙어 멀티태스킹과 파일이름을 255자까지 붙일 수 있었다.   
4.2버전에서는 시스템 간 통신도 가능해졌다.   
그후로도 유닉스에 SYSTEM V라는 명칭을 붙인 새로운 유닉스가 나타났다.   
리눅스는 GNU 운영체제를 시작으로 계속해서 발전해나갔다.   
유닉스는 POSIX를 사용하여 표준화했는데, 비공식적으로 각 표준은 POSIX다음에 소수로 표시했다.
* POSIX.1
핵심부, 운영체제 인터페이스
* POSIX.2
셸과 툴, 사용자 명령 등
* POSIX.3
표준 규격의 적합성 검증법
* POSIX.4
실시간 POSIX 확장
* POSIX.5
에이다 언어
* POSIX.6
보안 기능
## 2. 리눅스/유닉스의 구조
유닉스의 커널은 개별 관리자가 존재하지 않는다.   
그래서 거대한 프로그램 덩어리로 만든 모놀리식 커널과 개별 모듈로 구성된 마이크로 커널로 나뉜다.   
모놀리식 커널은 안정적이지만 부분 수정이 어렵다. 일반 시스템보다는 슈퍼컴퓨터에 많이 적용된다.   
마이크로 커널은 개별 모듈의 업로드, 언로드가 가능하다. 하지만 잘못된 모듈을 업로드 하면 커널 전체가 망가질 수도 있다.   
유닉스의 링 구조는 하드웨어 > 커널 > 셸 > 응용프로그램으로 구성되어있다.   
원래 링 구조가 높을 수록 보안이 높지만 유닉스는 윈도우보다 링 개수가 적지만 더 높은 보안 수준을 유지한다.   
커널 구조는 파일 서브시스템, 장치 드라이버, 프로세스 제어로 나누며, 커널의 파일 크기 또한 윈도우의 3/1정도이다.   
프로세스 제어에서는 전체 프로세스 간 통신과 스케줄링, 메모리 관리를 구현한다.   
장치 드라이버에서는 윈도우처럼 하드웨어와 소프트웨어를 연결하는 인터페이스를 제공한다.   
파일 서브시스템에서는 하드 디스크 같은 저장 공간에 유닉스 파일을 저장하고 읽는 역할을 한다.   
### 2-1. 셸
셸은 응용프로그램에서 명령을 받아 커널에 전송하는 역할을 한다.   
사용자의 키보드 입력을 인식하고, 해당 프로그램을 수행하기도 한다.   
셸 종류에는 본 셸, 콘 셸, C 셸로 나뉠 수 있다.   
셸의 주요 기능은 다음과 같다.
* 자체내장 명령어 제공
* 입출력, 오류의 방향 변경
* 와일드카드
* 파이프라인
* 조건부·무조건부 명령 열 작성
* 서브 셸 생성
* 백그라운드처리
* 셸 스크립트(프로그램) 작성
### 2-2. 리눅스/유닉스의 파일 시스템
유닉스에서 사용하는 파일은 4가지로 나뉜다.
* 일반 파일
데이터 파일이나 실행 파일이다. 텍스트 파일, BMP파일, EXE파일 등 말 그대로 일반적인 파일이다.   
반드시 디렉터리 하나에 포함되어 있어야 한다. 
* 디렉터리
디렉터리가 담고 있는 여러 파일과 하위 디렉터리 정보가 담겨 있다.
* 특수 파일
프린터나 터미널, 테이프 드라이버와 같은 물리적인 장치를 접근한다.    
특수파일은 /dev(device)에 있다. 
* 파이프 파일
파이프는 | 문자를 말하며, 명령 두 개를 연결할 때 사용한다.   
임시파일을 생성했다가 명령수행을 마치면 사라지는 것이다. 
|디렉터리|설명|
|--|--|
|/bin|기본적으로 실행 가능한 파일을 담고 있다.|
|/etc|시스템의 환경설정 및 주요 설정 파일을 담고 있다.|
|/tmp|프로그램 실행 및 설치할 때 생성하는 임시 파일을 담고 있다. 이 디렉터리에 파일을 저장하면 재부팅할 때 임의로 삭제될 수 있다.|
|/lib|기본 프로그램의 모듈을 담고 있다.|
|/boot|커널용 프로그램 파일을 담고 있으며, 부팅할 때 읽어서 수행한다.|
|/dev|프린터나 터미널 같은 물리적인 장치를 다루는 특수 파일을 담고 있다.|
|/home|각 사용자의 작업 디렉터리를 담고 있다. 각 계정으로 로그인할 때 이 디렉터리 아래에 있는 자신의 작업 디렉터리가 시작 디렉터리가 된다.|
|/usr|사용자가 직접 쓰는 파일을 담고 있다. 다른 디렉터리에 있는 파일이 똑같이 위치할 때가 많은데, 이는 링크되어 있는 것이다.|
|/usr/lib|C 언어나 포트란 라이브러리를 담고 있다.|
|/usr/include|C 언어에서 사용하는 헤더 파일을 담고 있다.|
## 3. 리눅스/유닉스의 부팅 순서
목적별로 고유의 부팅 프로세스가 있다.
##### Step1. POST 실행
##### Step2. 기본 부팅 관련 설정 사항 로드
##### Step3. MBR로드
##### Step4. 부트 로더 실행
부트 로더로 LILO나 GRUB를 사용한다.   
LILO는 /etc/lilo.conf에 설정사항을 저장한다.   
GRUB는 레드햇 7.x버전부터 기본 부트로더로 제공되는데, 사용이 편리하고 윈도우 계열 외에 다른 OS와 멀티 부팅이 가능하다. /etc/grub.conf(/boot/grub/grub.conf)에 설정사항을 저장한다.   
##### Step5. 실행 레벨에 따른 서비스 실행
부트로더는 스와퍼라는 pid 0번 프로세스를 실행하고, 스와퍼는 pid 1번 init(/sbin/init)프로세스를 실행한다.   
init프로세스는 다시 /etc/inittab 파일을 읽는다. inittab파일은 부팅할 기본모드를 선택하여 그에 따른 환경을 제공한다.   
부팅에 사용되는 실행레벨은 다음 일곱가지가 표준이다.
* 실행레벨 0
시스템을 종료할 때 사용된다.
* 살행레벨 1
단일 사용자 모드로, 기본적으로 관리자 권한의 셸을 얻는다. 그러나 대부분 데몬을 실행하지 않으므로 기능은 제약되어 있다. 
* 실행레벨 2 
NFS를 지원하지 않는 다중 사용자 모드이다.
* 실행레벨 3
일반 셸 기반의 인터페이스를 가진 다중 사용자 모드이다.
* 실행레벨 4
기본적으로 사용하지 않지만, 사용자가 임의로 정의하여 사용할 수 있다.
* 실행레벨 5
기본은 실행 레벨 3과 같으나, GUI환경을 지원한다.
* 실행레벨 6
재부팅한다.