# 80x86 시스템 메모리의 구조와 동작
## 1. 메모리의 기본 구조
#### 1-1. 스택
스택의 사전적 정의는 후입선출방식에 의해 정보를 관리하는 데이터 구조이다. 스택에서는 Top이라고 불리는 스택의 끝부분에서 데이터의 삽입과 삭제가 발생한다. 즉 스택에서는 Top위치에 정보가 위치한다. 그래서 스택에서는 가장 나중에 삽입된 정보가 가장 먼저 읽히는 특징이 있다.   
컴퓨터 메모리에서도 기본 작동 방식은 같다. 단지 차이는 스택에 저장되고 사용 목적이 프로그램 실행에 있다는 것뿐이다. 메모리상의 스택은 프로그램 함수 내부에서 정의하는데, 함수 종료와 동시에 사라지는 자동 변수가 저장되고 함수를 호출할 때 함수 내부의 로컬 변수 등이 저장되는 곳 이다. 함수를 실해하는 동안만 존재하며, 함수 실행을 종려하면 해당 변수들도 사라진다. ESP 레지스터는 항상 스택의 가장 위, 즉 끝을 가리킨다.
#### 1-2. 힙
힙의 사전적 정의는 프로그램의 실행 중 필요한 기억 장소를 할당하기 위해 운영체제에 예약되어 있는 기억 장소영역이다. 프로그램에서는 더 이상 기억장치가 필요 없으면 할당 받았던 기억 장소를 운영체제에 반납하는데, 이때 운영체제에서는 반납된 기억 장소를 다시 힙에게 돌려주게 된다. 기억장소는 포인터를 통해 동적으로 할당되거나 반환이 되며 연결 리스트, 트리, 그래프처럼 동적인 특성이 있는 데이터 구조에서 널리 사용된다.   
힙은 가변적인 양의 데이터를 저장하는 데 사용하는 메모리의 영역으로, 프로그램들로 할당되었다가 회수되는 작용을 되풀이한다. 힙은 프로그램들이 요구하는 블록 크기나 요구, 횟수 순서에 일정한 규칙이 없다. 대개 포인터 변수를 사용하여 동적으로 할당받고 돌려주는데, 이는 연결 리스트나 트리, 그래프 등 동적인 데이터 구조를 만드는데 꼭 필요하다. 프로그램 실행 중 해당 힙이 없어지면 메모리 부족으로 이상 종료를 하게 된다.   
프로그램에서는 new나 malloc()함수로 메모리를 동적으로 할당하여 힙 영역을 사용할 수 있다. 예를 들어 다음 코드는 힙 영역에 1000바이트를 할당한다. 
```c
char* p = new char[1000];
```
#### 1-3. BSS 세그먼트
초기화되지 않은 데이터 세그먼트라고도 하며, 프로그램을 실행할 때 0이나 NULL 포인터로 초기화되는 영역이다. 예를 들어 다음 코드는 static 변수 중 초기화 되지 않은 변수들을 저장한다.
```C
static int a;
```
#### 1-4. 데이터 세그먼트
초기화된 데이터 세그먼트라고도 하며, 초기화된 외부 변수나 static 변수 등을 저장하는 영역이다. 보통 텍스트 세그먼트와 데이터 세그먼트 영역을 합쳐 프로그램이라고 한다.
#### 1-5. 텍스트 세그먼트
CPU로 실행되는 머신 코드가 있는 영역으로, EIP가 다음에 실행하는 명령을 가리킨다.
## 2. 메모리 접근 모드와 동작
초기 8086 CPU를 사용한 IBM-PC는 등장 당시 메모리가 1MB였다. 당시에는 굉장히 큰 편이었지만, 요즈음에는 굉장히 작은 크기이다. 그래서 메모레에 접근하여 데이터를 저장하고 읽는 방법도 달라졌다.
#### 2-1. 실제 모드
x86 계열로 처음 등장한 8086 CPU에서 사용하던 동작 모드이다. 20비트 주소 버스로 총 1MB메모리를 사용할 수 있었다. 그리고 16비트 레지스터로 20비트 주소 버스를 사용했다. 20비트 주소를 나타내려고 세그먼트 레지스터를 도입하여 16비트 세그먼트 레지스터와 16비트 오프셋을 중첩시킨 20비트 물리 주소를 생성했다.   
예를 들어 세그먼트 주소인 CS 레지스터가 0x2525h이고 오프셋인 IP가 0x95F3h라면, 0x2525h 뒤에 한 자리의 0x0h를 붙여 95F3h를 더한 2E843h가 실제 가리키는 물리 주소가 된다. 이를 2525h:95F3h 또는 [CS]:95F3h로 표현한다.   
모든 메모리에는 세그먼트와 오프셋이 함께 필요하며, 세그먼트 하나를 사용하면 64KB메모리를 사용할 수 있다. 각 세그먼트 레지스터마다 사용하는 오프셋 레지스터는 다음과 같다.
<table>
  <tr>
    <td>세그먼트 레지스터</td>
    <td>오프셋 레지스터</td>
  </tr>
  <tr>
    <td>CS</td>
    <td>IP</td>
  </tr>
  <tr>
    <td>DS</td>
    <td>SI, DI, BX</td>
  </tr>
  <tr>
    <td>SS</td>
    <td>SP, BP</td>
  </tr>
   <tr>
    <td>ES</td>
    <td>SI, DI, BX</td>
  </tr>
</table>

실제 모드는 16비트 CPU 8086, 8026뿐만 아니라 80386 이상의 CPU에서도 지원하는데, 모든 프로그램은 처음 시작할 때는 실제 모드에서 동작한다.
#### 2-2. 보호모드
80286부터 도입한 모드로 32비트 CPU 80386에 이르러 완성된 모습을 보이며 현재에 이르렀다. 32비트 주소 버스를 사용하여 4GB메모리를 쓸 수 있으며, 메모리 보호 기능과 페이징 등으로 가상 메모리를 효율적으로 구현할 수 있다. 인터럽트나 예외 처리 등도 보호 모드에서 지원하는 기능을 활용한다.   
세그먼테이션과 페이징을 이용하여 메모리를 관리한다. 세그먼테이션은 4GB메모리를 세그먼트 단위로 쪼갠 것이다. 여기에서는 16비트 셀렉터와 32비트 오프셋을 이용하여 4GB 범위의 32비트 선형 주소를 생성하는 일을 한다. 이렇게 만든 선형 주소 메모리를 4KB단위로 쪼개서 관리하는 페이징을 이용하여 물리 주소로 변환한다. 