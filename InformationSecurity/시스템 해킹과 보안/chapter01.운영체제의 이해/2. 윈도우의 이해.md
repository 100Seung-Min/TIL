# 윈도우의 이해
## 1. 윈도우의 역사
1981년에 MS-DOS 1.0으로 시작한다. 또한 MS-DOS는 IBM 컴퓨터의 개인용 운영체제로 선택된다.   
1983년에 MS-DOS 2.0이 나오는데, 하드 디스크를 여러 개 장착할 수 있었다.   
1985년에 윈도우는 계속하여 발전해서 윈도우 1.0을 발표했다. 다중 처리 환경과 작업 절차가 단순해졌으나 큰 주목을 모으지는 못 했다.   
1987년 윈도우 2.0을 발표하자 DOS에서 설정한 기본 메모리인 640KB 이상의 프로그램이 생겨나기 시작했다.   
1987년에는 윈도우 386을 발표했는데, 3년 후에 발표하는 윈도우 3.0의 기초가 되었다.   
1992년에 발표한 윈도우 3.1은 대부분의 PC에 윈도우를 설치하는 분위기를 이끌었다.
1993년에는 DOS에서 시작한 PC용 운영체제인 윈도우를 서버용 운영체제의 개념인 NT버전으로 출시했다.   
1995년에는 윈도우 95를 발표했는데, TCP/IP, 전화접속네트워크, 긴 파일 이름 등 새로운 기능이 많아졌다.   
1998년에는 윈도우 98을 발표했으며, OSR2 버전은 꽤 높은 안정성을 보여주었다.   
이후에도 30여 년 동안 윈도우는 다양한 종류의 운영체제를 선보였다.   
또한 다른 수많은 경쟁사가 있었지만 현재까지 건재하고 있다.   
## 2. 윈도우의 구조
윈도우는 커널 구조와 파일 시스템 구조이다.   
커널은 운영체제의 중심에 위치하며, 운영체제에서의 모든 작업을 제어한다.   
즉 커널은 인터럽트 처리, 프로세스 관리, 메모리 관리, 파일 시스템 관리, 프로그래밍 인터페이스 제공 등 운영체제의 기본 기능의 핵심이다.
> ##### 인터럽트란?   
>
> 컴퓨터에 갑자기 문제가 발생한 경우 CPU가 하드웨어적으로 상태를 체크하여 변화에 대응하는 것이다.   
> 인터럽트가 발생하면, 인터럽트 처리 루틴이 작동하여 인터럽트를 해결하고, 인터럽트가 생기기 이전의 상태로 복귀한다.   
>
> ##### 인터럽트의 종류   
> * 기계 검사 인터럽트
> 프로그램 실행 중 갑작스런 정전이나 기계적인 문제가 발생할 때
> * 외부 인터럽트
> 오퍼레이터나 타이머가 프로그램을 의도적으로 중단할 때
> * 입출력 인터럽트
> 입출력 종료나 입출력 오류로 CPU기능이 요청될 때
> * 프로그램 검사 인터럽트
> 프로그램 실행 중 보호된 기억 공간에 접근했거나, 불법적인 명령 수행 같은 프로그램 문제가 발생할 때
### 2-1. 윈도우의 커널 구조
리눅스와 기본 개념은 같으나 형태는 다르다.   
동작할 때 커널을 손상하면 안 되므로 접근 가능한 메모리에 로드하지 않는 것이 일반적이다.   
커널이 손상되면 부팅 할 때 오류 문자와 함께 블루 스크린을 표시하는데, 이때는 운영체제를 새로 설치해야 한다.   
윈도우 시스템은 보통 링구조로 되어있다.   
링구조란 밑에서부터 하드웨어 > HAL > 마이크로 커널 > 각종 관리자 > 응용프로그램 순으로 위치한다.   
각 보안요소를 충족하고, 개별적으로 운영할 때 시스템 보안 수준이 높은 상태로 유지될 것이라는 생각에 고안되었다.   
또한 각종 관리자까지의 각 단계를 커널 모드로 구분하고, 마지막 링은 사용자 모드로 구분한다.   
커널 모드는 기본적으로 사용자가 접근 할 수 없는 영역으로, 기본 관리 시스템이 위치한다.   
하지만 마이크로 커널이 HAL을 무시하고, 하드웨어와 통신 할 수 있는 것과 같이 보안에서 허점을 만들었다.   
HAL은 하드웨어와 개발된 소프트웨어가 원활히 통신할 수 있는 번역자 역할을 한다.    
마이크로 커널은 본래 커널의 역할을 여러 관리자에게 분담시키고, 자신은 하드웨어와 하는 통신만 제어함으로써 최소한의 커널이 되었다.   
윈도우 관리자는의 역할은 각 명칭만으로 어떤 역할을 하는지 대략 알 수 있다.
* 입출력 관리자
시스템의 입출력을 제어한다. 장치 드라이버에서의 메시지, 응용 프로그램이 하드웨어를 곧바로 통신할 수 있는 통로를 제공한다.
* 개체 관리자
파일, 포트, 프로세스, 스레드 등 모든 것을 개체로 정의하는데, 이런 각 개체의 정보를 제공한다.   
* 보안 참조 관리자
각 데이터나 시스템 자원의 제어를 허가하거나 거부함으로써 시스템의 강제 보안 설정을 제공한다.
* 프로세스 관리자
스레드를 생성하고 요청에 따라 처리한다.
* 로컬 프로시저 호출 관리자
프로세스는 서로의 메모리 공간을 침범하지 못해서, 프로세스 간 통신이 필요할때 이를 대신한다.
* 가상 메모리 관리자
응용 프로그램의 요청에 따라 RAM 메모리를 할당하고, 가상 메모리의 페이징을 제어한다. 
* 그래픽 장치 관리자
화면에 선이나 곡선을 그리거나 폰트 등을 관리한다.
* 기타 관리자
캐시 관리자, PNP 관리자, 전원 관리자 등이 있다.

사용자 모드에는 다양한 응용 프로그램과 응용프로그램을 실행하는 서브시스템이 있다.   
서브 시스템은 윈도우에서 여러 응용 프로그램을 실행하는 컨테이너라고 할 수 있다.   
서브 시스템 중 하나인 Win32는 32비트 응용 프로그램이 동작할 수 있도록 도와주고, 기본 윈도우 사용자 인터페이스를 제공한다.   
즉 비디오 디스플레이, 키보드, 마우스 등을 지원한다.   
윈도우7이나 2008부터는 64비트 서브시스템을 지공한다.   
이외에 보안 서브시스템과 유닉스 운영체제에 기반을 둔 일련의 표준 운영체제 인터페이스로 POSIX가 있다.   
이런 보안 서브시스템은 사용자가 로그인 할 때 데이터를 보호하고, 운영체제가 이를 제어할 수 있도록 한다.   
윈도우10부터는 윈도우 리눅스 서브시스템을 도입해 리눅스 운영체제를 설치해서 리눅스 프로그램도 실행할 수 있도록 하였다.   
### 2-2 윈도우의 파일 시스템
단순히 데이터를 저장하는 것이 목적이 아니라 다양한 설정 및 보안 사항과 관련이 있다.   
윈도우에는 FAT, FAT32, NTFS와 같은 파일 시스템이 있다.   
* FAT
윈도우 95부터 시작되었다.
기본적으로 2GB까지를 한 파티션으로 설정할 수 있다.
테이블의 기본 크기는 16비트인데, 이는 하드 디스크에 파일을 담는 최소 단위인 클러스터가 32KB이기 때문이다.   
초기에는 충분한 듯 보였으나, 얼마 지나지 않아 너무 작게 여겨졌다.
* FAT32
윈도우 95 OSR2에서 시작되었다.
클러스터를 32비트개 가질 수 있어 기존의 FAT보다 비교할 수 없을 만큼 용량이 컸다.
현재에도 종종 사용되며, 호환성이 좋아 다른 운영체제에 정보를 옮길 때 유용하다.
그러나 접근 제어를 설정할 수 없다는 문제점으로 보안과는 거리가 먼 파일 시스템이다.
* NTFS
접근 제어가 적용된 윈도우 파일 시스템은 NT계열에서 사용되기 시작했다.
FAT와 OS/2파일 시스템이던 HPFS의 장점을 모아 만든 것이다.
개별 폴더와 파일에 사용 권한을 설정할 수 있고, 각 파일과 폴더에 해당 계정만 접근하여 읽을 수 있게 암호화 할 수 있기 때문에 보안이 다른 파일 시스템보다 좋다.
어떤 계정의 사람이 언제 파일을 열었는지, 파일을 성공적으로 열었는지를 알 수 있는 감사기능을 제공한다.
현재 윈도우에 적용된다.
## 윈도우의 부팅 순서
윈도우의 각 버전에 따라 부팅 프로세스가 다르다.
### 3-1. 윈도우 XP, 윈도우 서버 2000/2003의 부팅 순서
##### Step1. POST 실행
하드웨어 스스로가 시스템에 문제가 없는지 기본 사항을 검사하는 과정이다.   
BIOS가 POST를 실행하고, 라우터나 스위치 등 장비에서도 처음 스위치를 켤때 POST를 실행한다.   
그리고 하드웨어에서 문제를 발견하면 이 사실을 여러 방법으로 알린다.
##### Step2. 기본 부팅 관련 설정 상항 로드
CMOS에서 기본 부팅 매체 등 부팅 관련 사항을 설정한다.   
BIOS는 CMOS에 설정된 시스템 설정 사항 및 부팅과 관련된 여러 가지 정보를 읽어 시스템이 적용한다.
##### Step3. MBR(마스터 부트 레코드)로드
저장 매체의 첫 번째 섹터에 위치하는 512바이트 영역으로, 부팅 매체의 기본 파일 시스템 정보가 들어 있다.   
운영체제를 부팅할 때 저장 매체의 첫 번째 섹터를 호출하면 해당 부트 코드를 수행한다.   
부트 코드의 주 역할은 파티션 테이블에서 부팅 가능한 파티션을 찾아 해당 파티션의 부트 섹터를 호출하는 것이다.
부팅 가능한 파티션이 없으면 미리 정의된 오류 메시지를 출력한다. 
##### Step4. NTLDR 실행
하드 디스크의 부팅 파티션에 있는 프로그램으로 윈도우를 부팅할 수 있도록 간단한 파일 시스템을 실행한다.   
또한 boot.ini 파일 내용을 읽어 가능한 부팅 옵션을 보여준다.
boot.ini파일의 예시)
```
[boot loader]
timeout=30
default=multi(0)disk(0)rdisk(0)partiotion(3)\WINNT

[operating systems]
multi(0)disk(0)rdisk(0)partiotion(3)\WINNT="Windows 2000 Pro"
multi(0)disk(0)rdisk(0)partiotion(2)\WINNT="Windows NT Server Version 4.00"
```
timeout은 운영체제를 선택하는 화면에서 걸리는 대기 시간이다.   
default는 timeout동안 입력하지 않으면 default로 부팅한다.   
multi(0)은 SATA또는 E-IDE 컨트롤러를 가지는 디스크임을 나타낸다. 숫자 0은 첫 번째 컨트롤러를 의미한다.   
SCSI 컨트롤러에 부착된 디스크에서 부팅할 때는 multi(0) 대신 scsi(0)을 쓴다.   
disk(0)은 scsi로 시작할 때를 표현한다.   
rdisk(0)은 IDE, E-IDE, SCSI with BIOS방식의 디스크에 해당하는 표현이다. 여기에서도 0은 해당 컨트롤러의 첫 번째 디스크를 의미한다.   
partition(3)은 파티션 순서를 나타낸다. 1부터 시작하므로 세 번째 파티션에 운영체제가 있음을 나타낸다.   
[operating systems]에서는 선택할 수 있는 운영체제를 위의 규칙에 따라 나열한다.
##### Step5. NTDETECT.com 실행
NTDETECT는 NTLDR에서 제어권을 위임받아 시스템에 설치한 다음 하드웨어를 검사한다.
* PC의 CPU유형
* 버스 유형
* 비디오 보드 유형
* 키보드와 마우스 종류
* 컴퓨터에 장착된 직렬 포트와 병렬 포트
* 플로피 드라이브

NTDETECT가 문제없이 작동되면 레지스트리의 하드웨어키를 만든다.   
이 키는 HKEY_LOCAL_MACHINE에 있다.   
컴퓨터를 재부팅 할 때마다 만들기에 항상 현재의 하드웨어를 구성한다.
##### Step6. ntoskrnl.exe 실행
ntoskrnl은 HAL.DLL을 로드한다. ntoskrnl로드는 다음 네가지로 나누어 생각할 수 있다.
* 커널 로드
시스템 설정을 로드하고, 이것을 HKEY_LOCAL_MACHINE\System\Current\Controlset\Services에 저장한다.   
이 정보를 확인하여 로드할 드라이브와 그 순서를 결정한다.
* 커널 초기화
드라이버에서 현재 제어 설정을 검사하고 작업을 시작한다.
* 서비스 로드
세션 관리자 서브시스템(smss.exe)과 Win32 서브시스템을 로드한다.
* 서브시스템 시작
윈도우 서브시스템을 초기화한다. Win32서브시스템은 로그인을 처리하고 Winlogon.exe를 시작한다.   
Ctrl+Alt+Delete를 누르면 로그인 창을 활성화하고, 계정과 패스워드를 입력받아 로컬 보안 인증 서버(lsass.exe)에 보낸다.   
전달 받은 로컬 보안 인증 서버는 보안 계정 관리자에 저장된 정보와 비교하여 서로 일치하면 Userinit.exe프로세스가 HKEY_LOCAL_MACHINE\SOFTWARE\Microsft\Window NT\ CurrentVersion\Winlogon의 셸 값에서 참조되는 셸을 실행한다.
### 3-2 윈도우 비스타 이후 버전 부팅 순서
기존 부팅 순서와 약간 다르지만 기본 순서와 구성은 거의 같다.
##### Step1~3. POST 실행 및 기본 부팅 관련 설정 사항 로드, MBR 로드
POST와 CMOS에서 기본 부팅 관련 설정 사항 및 MBR 로딩은 위의 내용과 같다.
##### Step4. 윈도우 부트 서브시스템 실행
bootmgr.exe를 실행하고, 부트 설정 데이터(BCD)를 읽어 실행 가능한 운영체제의 목록을 보여준다.
이것은 NTLDR이 boot.ini를 읽어 보여주는 것과 같다.
BCD는 boot.ini처럼 텍스트 파일이 아니고, bcdedit.exe를 이용하여 편집이 가능하다.
##### Step5. 윈도우 OS 로더(winload.exe)실행
NTDETECT처럼 각종 장치 드라이버를 로드하고, ntoskrnl.exe를 실행한다.